#Философия студийной разметки#
_based on BEM-methodology and Bootstrap Framework_

Главная цель, которую мы преследуем своей работой, быть удобным инструментом. Быть понятным инструментом, быть инструментом легкозаменимым. Как для коллег верстальщиков, так и для фронт-енд команды.

Наша задача - выполнить свою работу качественно, и настолько просто, чтобы специалист уровня Junior, мог по образу и подобию собрать новые компоненты, шаблоны и страницы.

Поэтому философия нашей верстки опирается на три кита: атомная разметка, БЭМ, Бутстрап. 

На момент создания стандарта, в качестве основного фреймворка используется Angular-JS. Как следствие, большинство готовых компонент для Ангулара разработано в рамках Bootstrap. Порог вхождения в него достаточно низок, что и обусловило его успешность в среде фронтенд-разработчиков. Бороться с этим глупо и неконструктивно. Поэтому текущая версия стандарта опирается на фрейемворк Bootstrap.

Методология именования классов БЭМ настолько хороша, что даже отвратительно выполненная верстка, с каскадами на 3 и даже 4 уровня в имени, устойчива к многочисленным ротациям дизайна и многочисленным изменениям. Выполенная согласно этой методолгии верстка выдержит agile-шторм куда намного лучше проекта, сверстанного в рамках олд-скульного каскада. БЭМ ‒ наш второй кит:

Блоки. Элементы. Модификаторы

0. При выборе имени класса опирайтесь на семантику, а не внешний вид или расположение

1. Блок является независимыми, самостоятельными сущностями:
```css
'header', 'menu', 'content', 'sidebar'
```

2. Элемент не имеет смысла вне блока:
```css
'menu__item'
```

3. Блок может быть вложен в другой блок:
```css
'header' > 'menu'
```

4. У элемента не может быть элемента:
```css
BAD	'menu__item__link'
GOOD	'menu__link'
```


5. Глобальный модификаторы начинаются с нижнего прочерка и аппер-кейса:
```css
'_Width100' -> ._Width100 {width:100%}
```

6. Контестные модификаторы не имеют смысла в отрыве от блока-элемента, начинаются с нижнего прочерка и ловер-кейса:
```css
'menu__item _horizontal' -> .menu__item._horizontal {float:none; display:block}
```

7. Миксуем свойства блоков и элементов, так как в одно и тоже время блок ТАКЖЕ может быть и ЭЛЕМЕНТОМ другого блока:
```css
	'menu__item btn' -> .menu__item.btn (display:block; width:100%)
```

8. При написании код МАКСИМАЛЬНО уходим от каскада. Любые желаемые свойства передаем через класс-мождификатор

##Как понять, где блок, а где элемент?##
Если фрагмент кода может использоваться повторно и не зависит от реализации других компонентов страницы, необходимо создавать блок.
Если фрагмент кода не может использоваться самостоятельно, без родительской сущности (блока), в большинстве случаев создается элемент.

Рассмотрим два решения ‒ неправильное и правильное:
```css
.search
.search__input
.search__button
```

Неверно, так как стили для инпута и кнопки могут быть переиспользованы многократно

Стоит переосмыслить в таком виде:
```css
.search
.form-control
.btn
```

***КАК ПОНЯТЬ, ЧТО ЧТО-ТО ПОШЛО НЕ ТАК?***
1. В имени класса три и более каскада:
```css
'block__elem__elem2'
```
2. Внутри CSS вы используете каскад:
```css
'block__elem .block2__elem {background:red}'
```


Третьим китом является атомизированная разметка. Она наглядна, местами избыточна и максимально упрощена. Что мы подразумеваем под этим?

###Атомы
>Атомы - палитры цветов, шрифты, индивидуальные элементы (например, заголовки, абзацы, кнопки и т.д.) и прочие вещи, которые соединяются с другими атомами для создания молекулы.

###Молекулы
>Молекулы – это кусочки системы, которые мы строим из атомов. И хотя молекулы требуют атомы, они больше похожи на блоки лего-конструктора, из которого складываются более сложные вещи. Молекулы включают такие элементы, как поля формы с надписью или таблица с заголовками и колонками данных.

###Организмы
>С организмов мы уже получаем более-менее целостный вид интерфейса. Комбинируя молекулы, мы можем создавать более сложные, но повторяемые, кусочки нашего продукта. Пример организма – главная навигация на страничке, которая включает лого, ссылки навигации и поле поиска или кнопку регистрации.

###Шаблоны
>Шаблоны – это по сути наши каркасные модели или макеты. Комбинируя множество организмов, мы действительно начинаем видеть целостную картину того, что мы создаем. Если высокоточный, детальный результат не требует, с этой точки мы можем уже начать реализовывать нашу систему в коде.

###Страницы
>Страницы – это уже более детализированная версия шаблонов. Здесь уже становится понятно, что за проект мы создаем.

Основным признаком атомной верстки являются __Глобальные__ и __Контекстные Модификаторы__. Это классы, которые сложно перепутать с другими ‒ глобальные начинаются с нижнего прочерка и большой буквы: 
```css
"_ColorBlue" (._ColorBlue{color:blue;}), "_FontSize-XL" (font-size:24px), "_HasNoBorder" (border:none;). 
```
Также к ним относятся так называемые костыли, которыми подпираются желания клиента или дизаайнера, в противовес основным элементам и сетке: 
```css
"_MargBott5p" (margin-bottom:5px;), "_Width50" (width:50%;), "_Width50p" (width:50px;)
```
и т.д.

Контекстные модификаторы имеют смысл только в паре с классом блока, и от глобальных их отличает нижний регистр первого слова: 
```css
	"_alt" (.header._alt), "_colored" (.bodyBlock._colored).
```

Молекулы, взятые из бутстрапа, имеют своё именование. Создавая с нуля, мы опираемся на методологию БЭМ. Каждая молекула, блок поиска к примеру, имеет свою законченную структуру без каскада в CSS. Она может быть создан как на основе бутстрапа, так и с нуля на БЭМе, включая также и миксированный подход:
```css
	div.searchBlock. 
		input.searchBlock__field
		button.searchBlock__button 
	div.searchBlock. 
		input.form-filed
		button.btn
	div.searchBlock. 
		input.searchBlock__field form-filed
		button.searchBlock__button btn
	div.searchBlock. 
		input.form-filed _alt
		button.btn _HasNoBorder
```
Подобным подходом мы добиваемся самодостаточности кода. Любой фронтенд-разработчик сможет скопировать HTML со всеми классами (или их частью) в любое место, и он будет вести себя предсказуемо.
